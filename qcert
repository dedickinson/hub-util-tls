#!/usr/bin/env python3
# PYTHON_ARGCOMPLETE_OK

import argparse
import argcomplete
import datetime
from pathlib import Path
import configparser

from cryptography import x509
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.backends import default_backend


class CertificateStore:
    class InvalidCertificateTypeException(Exception):
        def __init__(self, message):
            super().__init__(message)

    class CertificateType:
        def __init__(self, name: str, dir: str = None,
                     extensions=[]):
            self.name = name
            self.dir = dir
            self.extensions = extensions

            if not self.dir:
                self.dir = self.name

    @staticmethod
    def build_certificate_attributes(cls, country_name: str = '', state_name: str = '', 
       locality_name: str = '', organization_name: str = '', common_name: str = '') -> x509.Name:
       
        return x509.Name([
            x509.NameAttribute(NameOID.COUNTRY_NAME, country_name),
            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME,state_name),
            x509.NameAttribute(NameOID.LOCALITY_NAME, locality_name),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, organization_name),
            x509.NameAttribute(NameOID.COMMON_NAME, common_name)
        ])

    @classmethod
    def configure_cert_store_path(cls, path: Path, mode: int, enforce_dir_mode: bool) -> Path:
        path.mkdir(mode=mode, exist_ok=True)

        if not path.exists():
            raise FileNotFoundError(f'{path}')

        if enforce_dir_mode and not (path.stat().st_mode == mode + 0o40000):
            raise FileNotFoundError(
                f'{path} has incorrect permissions - expected {oct(mode)}')

        return path

    @staticmethod
    def create_rsa_key(cls, key_size: int = 2048, public_exponent: int = 65537):
        return rsa.generate_private_key(
            public_exponent=public_exponent,
            key_size=key_size,
            backend=default_backend()
        )

    @staticmethod
    def create_rsa_cert(cls, private_key, certificate_type: CertificateType,
                        subject:x509.Name, issuer:x509.Name,
                        certificate_duration_days: int = 360):

        one_day = datetime.timedelta(1, 0, 0)
        public_key = private_key.public_key()

        builder = x509.CertificateBuilder(
        ).not_valid_before(
            datetime.datetime.today() - one_day
        ).not_valid_after(
            datetime.datetime.today() + (one_day * certificate_duration_days)
        ).serial_number(
            x509.random_serial_number()
        ).public_key(
            public_key
        ).subject_name(
            subject
        ).issuer_name(
            issuer
        )

        for extension in certificate_type.extensions:
            builder = builder.add_extension(
                extension, critical=True)

        certificate = builder.sign(
            private_key=private_key, algorithm=hashes.SHA256(),
            backend=default_backend()
        )

        return certificate


    CERTIFICATE_TYPE_ROOT = 'root'
    CERTIFICATE_TYPE_INTERMEDIATE = 'intermediate'
    CERTIFICATE_TYPE_SERVER = 'server'
    CERTIFICATE_TYPE_CLIENT = 'client'
    CERTIFICATE_TYPES = {
        CERTIFICATE_TYPE_ROOT: CertificateType(CERTIFICATE_TYPE_ROOT,
                                                         extensions=[x509.BasicConstraints(ca=True, path_length=None)]),
        CERTIFICATE_TYPE_INTERMEDIATE: CertificateType(CERTIFICATE_TYPE_INTERMEDIATE),
        CERTIFICATE_TYPE_SERVER: CertificateType(CERTIFICATE_TYPE_SERVER,
                                                           extensions=[x509.BasicConstraints(ca=False, path_length=None)]),
        CERTIFICATE_TYPE_CLIENT: CertificateType(
            CERTIFICATE_TYPE_CLIENT)
    }

    def __init__(self, path: str,
                 dir_mode=0o700, file_mode=0o400,
                 key_size: int = 2048, key_public_exponent: int = 65537,
                 enforce_mode=True, config_file: str = 'config.ini',
                 certificate_types=CERTIFICATE_TYPES):

        self.cert_types = certificate_types

        self.dir_mode = dir_mode
        self.file_mode = file_mode
        self.enforce_mode = enforce_mode
        self.config_file = config_file
        self.key_size = key_size
        self.key_public_exponent = key_public_exponent

        self.config = configparser.ConfigParser()

    def initialise(self):
        # Setup the base path
        self.base_path = Path(path).expanduser()
        CertificateStore.configure_cert_store_path(
            self.base_path, self.dir_mode, self.enforce_mode)

        # Setup sub-paths for the various cert types
        for key, val in self.cert_types.items():
            CertificateStore.configure_cert_store_path(
                self.get_cert_path(val), self.dir_mode, self.enforce_mode)

    def list(self, cert_type: CertificateType=None):
        print("List")

    def info(self,cert_type: CertificateType, cert_name=None):
        print("Info")

    def info(self,cert_path:str):
        tokens = cert_path.split('/')
        cert_type_name = tokens[0]
        if not self.check_valid_cert_type(cert_type_name):
            raise self._get_exception_invalid_certificate_type(cert_type_name)

        cert_name = tokens[1]
        print(f'Type: {cert_type_name}; Name: {cert_name}')

    def get_cert_path(self, cert_type: CertificateType, cert_name=None):
        if cert_name:
            return Path(self.base_path, cert_type.dir, cert_name)

        return Path(self.base_path, cert_type.dir)

    def get_validate_cert_types(self):
        return self.cert_types.keys()

    def check_valid_cert_type(self, cert_type_name: str):
        return cert_type_name in self.cert_types.keys()

    def certificate_exists(self, cert_type_name: str, cert_name: str):
        # TODO: Get this working
        return False

    def create_certificate(self, cert_type_name: str, cert_name: str):
        if not self.check_valid_cert_type(cert_type_name):
            raise Exception(f'Invalid certificate type: {cert_type_name}')

        if self.certificate_exists(cert_type_name, cert_name):
            raise Exception(
                f'Certificate of type {cert_type_name} with name {cert_name} exists')

        cert_type = self.cert_types[cert_type_name]
        cert_path: Path = self.get_cert_path(cert_type, cert_name)
        CertificateStore.configure_cert_store_path(
            cert_path, self.dir_mode, self.enforce_mode)

    

    def _get_exception_invalid_certificate_type(self, cert_type_name:str):
        return CertificateStore.InvalidCertificateTypeException(f'Invalid certificate type: {cert_type_name}. Allowed types: {list(self.get_validate_cert_types())}')
        


class QuickCertCli:

    default_path: str = '~/.qcert'
    default_key_size: int = 2048
    prog_version = '0.1'

    def create_argparser(self):

        shared_arg_dict = {
            'certificate_store': {
                'default': QuickCertCli.default_path,
                'help': 'The cert store path'
            }
        }

        parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                         description='Lazy toolkit for creating certs')

        parser.add_argument('--version', action='version',
                            version=f'%(prog)s {QuickCertCli.prog_version}')

        parser.add_argument(
            '--certificate_store', **shared_arg_dict['certificate_store'])

        subparsers = parser.add_subparsers(title='commands',
                                           dest='cmd',
                                           help='sub-command help')

        parser_init = subparsers.add_parser(
            'init',
            help='Initialises the certificate store')

        parser_list = subparsers.add_parser(
            'list',
            help='Lists the certificates in the certificate store')

        parser_list = subparsers.add_parser(
            'info',
            help='Get information about a certificate')

        parser_list.add_argument('cert_path', type=str,
            help='The type/name of the cert - e.g. server/www.example.com')

        parser_create = subparsers.add_parser(
            'create',
            help='Create a certificate')

        parser_create.add_argument('cert_type', type=str,
                                   choices=['root', 'intermediate',
                                            'server', 'client'],
                                   help='the type of certificate')

        parser_create.add_argument('name', type=str,
                                   help='the certificate name')

        parser_create.add_argument('--key-size', type=str,
                                   required=False,
                                   default=QuickCertCli.default_key_size,
                                   help='the key size')

        return parser

    def create_cert(self, cert_type: str, name: str):
        self.cert_store.create_certificate(cert_type, name)

    def init_cert_store(self):
        self.cert_store.initialise()

    def list_certs(self):
        self.cert_store.list()

    def get_info(self, cert_path:str):
        self.cert_store.info(cert_path)

    def run(self):
        parser = self.create_argparser()

        # Refer to https://github.com/kislyuk/argcomplete
        argcomplete.autocomplete(parser)

        args = parser.parse_args()

        if not args.cmd:
            parser.print_help()
            quit()

        self.cert_store = CertificateStore(args.certificate_store)

        if args.cmd == 'create':
            self.create_cert(args.cert_type, args.name)
        elif args.cmd == 'init':
            self.init_cert_store()
        elif args.cmd == 'list':
            self.list_certs()
        elif args.cmd == 'info':
            self.get_info(args.cert_path)


if __name__ == "__main__":

    QuickCertCli().run()
