#!/usr/bin/env python3
# PYTHON_ARGCOMPLETE_OK

import argparse
import argcomplete
import datetime
from pathlib import Path
import configparser
import logging
import os
import base64
import math
from itertools import islice, repeat, filterfalse

from cryptography import x509
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization

import numpy as np

logger = logging.getLogger(__name__)


def produce_amount_keys(amount_of_keys):
    # See: https://stackoverflow.com/questions/48421142/fastest-way-to-generate-a-random-like-unique-string-with-random-length-in-python

    def unique_everseen(iterable, key=None):
        "List unique elements, preserving order. Remember all elements ever seen."
        # unique_everseen('AAAABBBCCDAABBB') --> A B C D
        # unique_everseen('ABBCcAD', str.lower) --> A B C D
        seen = set()
        seen_add = seen.add
        if key is None:
            for element in filterfalse(seen.__contains__, iterable):
                seen_add(element)
                yield element
        else:
            for element in iterable:
                k = key(element)
                if k not in seen:
                    seen_add(k)
                    yield element

    def gen_keys(_urandom=os.urandom, _encode=base64.b32encode, _randint=np.random.randint):
        # (count / math.log(256, 32)), rounded up, gives us the number of bytes
        # needed to produce *at least* count encoded characters
        factor = math.log(256, 32)
        input_length = [None] * 12 + \
            [math.ceil(l / factor) for l in range(12, 20)]
        while True:
            count = _randint(12, 20)
            yield _encode(_urandom(input_length[count]))[:count].decode('ascii')
    return list(islice(unique_everseen(gen_keys()), amount_of_keys))


class CertificateStore:
    class InvalidCertificateTypeException(Exception):
        def __init__(self, message):
            super().__init__(message)

    class CertificateType:
        def __init__(self, name: str, dir: str = None,
                     extensions=[]):
            self.name = name
            self.dir = dir
            self.extensions = extensions

            if not self.dir:
                self.dir = self.name

    @staticmethod
    def build_certificate_attributes(cls, country_name: str = '', state_name: str = '',
                                     locality_name: str = '', organization_name: str = '', common_name: str = '') -> x509.Name:

        return x509.Name([
            x509.NameAttribute(NameOID.COUNTRY_NAME, country_name),
            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, state_name),
            x509.NameAttribute(NameOID.LOCALITY_NAME, locality_name),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, organization_name),
            x509.NameAttribute(NameOID.COMMON_NAME, common_name)
        ])

    @classmethod
    def configure_cert_store_path(cls, path: Path, mode: int, enforce_dir_mode: bool) -> Path:
        logger.debug(f'Creating certificate store path: {path}')
        path.mkdir(mode=mode, exist_ok=True)

        if not path.exists():
            raise FileNotFoundError(f'{path}')

        if enforce_dir_mode and not (path.stat().st_mode == mode + 0o40000):
            raise FileNotFoundError(
                f'{path} has incorrect permissions - expected {oct(mode)}')

        return path

    CERTIFICATE_TYPE_ROOT = 'root'
    CERTIFICATE_TYPE_INTERMEDIATE = 'intermediate'
    CERTIFICATE_TYPE_SERVER = 'server'
    CERTIFICATE_TYPE_CLIENT = 'client'
    CERTIFICATE_TYPES = {
        CERTIFICATE_TYPE_ROOT: CertificateType(CERTIFICATE_TYPE_ROOT,
                                               extensions=[x509.BasicConstraints(ca=True, path_length=None)]),
        CERTIFICATE_TYPE_INTERMEDIATE: CertificateType(CERTIFICATE_TYPE_INTERMEDIATE),
        CERTIFICATE_TYPE_SERVER: CertificateType(CERTIFICATE_TYPE_SERVER,
                                                 extensions=[x509.BasicConstraints(ca=False, path_length=None)]),
        CERTIFICATE_TYPE_CLIENT: CertificateType(
            CERTIFICATE_TYPE_CLIENT)
    }

    def __init__(self, path: str,
                 dir_mode=0o700, file_mode=0o400,
                 key_size: int = 2048, key_public_exponent: int = 65537,
                 enforce_mode=True, config_file: str = 'config.ini',
                 certificate_types=CERTIFICATE_TYPES):

        self.cert_types = certificate_types

        self.base_path = Path(path).expanduser()
        self.dir_mode = dir_mode
        self.file_mode = file_mode
        self.enforce_mode = enforce_mode
        self.config_file = config_file
        self.key_size = key_size
        self.key_public_exponent = key_public_exponent

        self.config = configparser.ConfigParser()

    def initialise(self):
        # Setup the base path
        CertificateStore.configure_cert_store_path(
            self.base_path, self.dir_mode, self.enforce_mode)

        with open(os.open(Path(self.base_path, 'shadow'), os.O_CREAT | os.O_WRONLY, 0o600), "w") as f:
            f.write("""# Passphrase file
[root]

[intermediate]

[server]

[client]
""")

        with open(os.open(Path(self.base_path, 'config.ini'), os.O_CREAT | os.O_WRONLY, 0o600), "w") as f:
            f.write("""
            
""")

        # Setup sub-paths for the various cert types
        for key, val in self.cert_types.items():
            CertificateStore.configure_cert_store_path(
                self.get_cert_path(val), self.dir_mode, self.enforce_mode)

    def list(self, cert_type: CertificateType = None):
        print("List")

    def info(self, cert_type: CertificateType, cert_name=None):
        print("Info")

    def info(self, cert_path: str):
        tokens = cert_path.split('/')
        cert_type_name = tokens[0]
        if not self.check_valid_cert_type(cert_type_name):
            raise self._get_exception_invalid_certificate_type(cert_type_name)

        cert_name = tokens[1]
        print(f'Type: {cert_type_name}; Name: {cert_name}')

    def get_cert_path(self, cert_type: CertificateType, cert_name=None):
        if cert_name:
            return Path(self.base_path, cert_type.dir, cert_name)

        return Path(self.base_path, cert_type.dir)

    def get_validate_cert_types(self):
        return self.cert_types.keys()

    def check_valid_cert_type(self, cert_type_name: str):
        return cert_type_name in self.cert_types.keys()

    def certificate_exists(self, cert_type_name: str, cert_name: str):
        cert_type = self.cert_types[cert_type_name]
        if self.get_cert_path(cert_type, cert_name).exists():
            return True
        return False

    def certificate_exists(self, cert_type: CertificateType, cert_name: str):
        if self.get_cert_path(cert_type, cert_name).exists():
            return True
        return False

    def create_certificate(self, cert_type_name: str, cert_name: str, passphrase: str = None):

        def create_rsa_key():
            return rsa.generate_private_key(
                public_exponent=self.key_public_exponent,
                key_size=self.key_size,
                backend=default_backend()
            )

        def store_key(name: str, path: Path, key):
            with open(os.open(Path(path, f'{name}.key.pem'), os.O_CREAT | os.O_WRONLY, self.file_mode), "wb") as f:
                f.write(key.private_bytes(
                    encoding=serialization.Encoding.PEM,
                    format=serialization.PrivateFormat.TraditionalOpenSSL,
                    encryption_algorithm=serialization.BestAvailableEncryption(
                        b"passphrase"),
                ))

        def create_rsa_cert(private_key, certificate_type: CertificateStore.CertificateType,
                            subject: x509.Name, issuer: x509.Name,
                            certificate_duration_days: int = 360):

            one_day = datetime.timedelta(1, 0, 0)
            public_key = private_key.public_key()

            builder = x509.CertificateBuilder(
            ).not_valid_before(
                datetime.datetime.today() - one_day
            ).not_valid_after(
                datetime.datetime.today() + (one_day * certificate_duration_days)
            ).serial_number(
                x509.random_serial_number()
            ).public_key(
                public_key
            ).subject_name(
                subject
            ).issuer_name(
                issuer
            )

            for extension in certificate_type.extensions:
                builder = builder.add_extension(
                    extension, critical=True)

            certificate = builder.sign(
                private_key=private_key, algorithm=hashes.SHA256(),
                backend=default_backend()
            )

            return certificate

        def store_certificate(name: str, path: Path, certificate):
            with open(os.open(Path(path, f'{name}.cert.pem'), os.O_CREAT | os.O_WRONLY, self.file_mode), "wb") as f:
                f.write(cert.public_bytes(serialization.Encoding.PEM))

        if not self.check_valid_cert_type(cert_type_name):
            raise Exception(f'Invalid certificate type: {cert_type_name}')

        cert_type = self.cert_types[cert_type_name]
        cert_path: Path = self.get_cert_path(cert_type, cert_name)

        if self.certificate_exists(cert_type, cert_name):
            raise Exception(
                f'Certificate of type {cert_type_name} with name {cert_name} exists')

        CertificateStore.configure_cert_store_path(
            cert_path, self.dir_mode, self.enforce_mode)

        key = create_rsa_key()
        store_key(cert_name, cert_path, key)

        #Todo: complete
        #cert = create_rsa_cert(key, cert_type, )
        #store_certificate(cert_name, cert_path, cert)

    def _get_exception_invalid_certificate_type(self, cert_type_name: str):
        return CertificateStore.InvalidCertificateTypeException(f'Invalid certificate type: {cert_type_name}. Allowed types: {list(self.get_validate_cert_types())}')


class QuickCertCli:

    default_path: str = '~/.qcert'
    default_key_size: int = 2048
    prog_version = '0.1'

    def create_argparser(self):

        shared_arg_dict = {
            'certificate_store': {
                'default': QuickCertCli.default_path,
                'help': 'The cert store path'
            }
        }

        parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                         description='Lazy toolkit for creating certs')

        parser.add_argument('--version', action='version',
                            version=f'%(prog)s {QuickCertCli.prog_version}')

        parser = argparse.ArgumentParser(fromfile_prefix_chars='@')

        parser.add_argument(
            '--certificate_store', **shared_arg_dict['certificate_store'])

        subparsers = parser.add_subparsers(title='commands',
                                           dest='cmd',
                                           help='sub-command help')

        parser_init = subparsers.add_parser(
            'init',
            help='Initialises the certificate store')

        parser_list = subparsers.add_parser(
            'list',
            help='Lists the certificates in the certificate store')

        parser_list = subparsers.add_parser(
            'info',
            help='Get information about a certificate')

        parser_list.add_argument('cert_path', type=str,
                                 help='The type/name of the cert - e.g. server/www.example.com')

        parser_create = subparsers.add_parser(
            'create',
            help='Create a certificate')

        parser_create.add_argument('cert_type', type=str,
                                   choices=['root', 'intermediate',
                                            'server', 'client'],
                                   help='the type of certificate')

        parser_create.add_argument('name', type=str,
                                   help='the certificate name')

        parser_create.add_argument('--key-size', type=str,
                                   required=False,
                                   default=QuickCertCli.default_key_size,
                                   help='the key size')

        parser_create_passphrase_group = parser_create.add_mutually_exclusive_group(
            required=False)

        parser_create_passphrase_group.add_argument('--passphrase', action='store_const',
                                                    const=True,
                                                    help='If flagged you\'ll be asked to provide a passphrase for the key')

        parser_create_passphrase_group.add_argument('--no-passphrase', action='store_const',
                                                    const=True,
                                                    help='If flagged no passphrase is used for the key')

        parser_create_passphrase_group.add_argument('--random-passphrase', action='store_const',
                                                    const=True,
                                                    help='If flagged a random passphrase is created for the key (default)')

        parser_pubkey = subparsers.add_parser(
            'public_key',
            help='Outputs the public key from the requested key')

        parser_pubkey.add_argument('name', type=str,
                                   help='the key name')

        parser_genrnd = subparsers.add_parser(
            'random',
            help='Outputs a random string')

        return parser

    def create_cert(self, cert_type: str, name: str, passphrase:str):
        self.cert_store.create_certificate(cert_type, name, passphrase)

    def init_cert_store(self):
        self.cert_store.initialise()

    def list_certs(self):
        self.cert_store.list()

    def get_info(self, cert_path: str):
        self.cert_store.info(cert_path)

    def get_random(self) -> str:
        print(produce_amount_keys(1)[0])

    def run(self):
        parser = self.create_argparser()

        # Refer to https://github.com/kislyuk/argcomplete
        argcomplete.autocomplete(parser)

        args = parser.parse_args()

        if not args.cmd:
            parser.print_help()
            quit()

        self.cert_store = CertificateStore(args.certificate_store)

        if args.cmd == 'create':
            if args.passphrase:
                passphrase = input('Please provide a passphrase: ')
            elif args.no_passphrase:
                passphrase = ''
            else:
                passphrase = produce_amount_keys(1)[0]

            self.create_cert(args.cert_type, args.name, passphrase)
        elif args.cmd == 'init':
            self.init_cert_store()
        elif args.cmd == 'list':
            self.list_certs()
        elif args.cmd == 'info':
            self.get_info(args.cert_path)
        elif args.cmd == 'random':
            self.get_random()


if __name__ == "__main__":
    logger.setLevel(logging.DEBUG)
    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)
    ch.setFormatter(logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
    logger.addHandler(ch)

    QuickCertCli().run()
